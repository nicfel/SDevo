package sdevo.bdmm;

import beast.core.BEASTObject;
import beast.core.CalculationNode;
import beast.core.Input;
import beast.core.Loggable;
import beast.evolution.tree.Node;
import beast.evolution.tree.Tree;
import cern.colt.Arrays;

import java.io.PrintStream;

import bdmmprime.mapping.TypeMappedTree;

/**
 * Logger which takes a typed tree generated by TypeMappedTree and
 * produces tree log entries in which only the types at internal coalescent
 * nodes are preserved, i.e. all type-change nodes are stripped away.
 *
 * This is useful for producing tree files which can be fed into TreeAnnotator.
 *
 * @author Tim Vaughan <tgvaughan@gmail.com>
 */
public class JointLogger extends CalculationNode implements Loggable {

    public Input<TypeMappedTree> typedTreeInput = new Input<>(
            "typedTree",
            "Typed tree whose node types to log.",
            Input.Validate.REQUIRED);
    
    public Input<FlatTypeMappedTree> flatTypedTreeInput = new Input<>(
            "flatTypedTree",
            "Typed tree whose node types to log.",
            Input.Validate.REQUIRED);


    private TypeMappedTree typedTree;
    private FlatTypeMappedTree flatTypedTree;


    @Override
    public void initAndValidate() {
        typedTree = typedTreeInput.get();
        flatTypedTree = flatTypedTreeInput.get();
    }

    @Override
    public void init(PrintStream out) {
        typedTree.init(out);
    }

    @Override
    public void log(long nSample, PrintStream out) {

        typedTree.remapForLog(nSample);
        flatTypedTree.remapForLog(nSample);

        // Set up metadata string
        out.print("tree STATE_" + nSample + " = ");
        out.print(getStrippedNewick(typedTree.getRoot()));
        out.print(";");
    }

    @Override
    public void close(PrintStream out) {
        typedTree.close(out);
    }

    /**
     * Construct a newick representation of the given typed tree, but with
     * type-change nodes stripped away.  Useful for feeding into TreeAnnotator
     * to produce summary trees with (limited) type information.
     *
     * @param node root of typed tree.
     * @return newick representation.
     */
    public String getStrippedNewick(Node node) {

        StringBuilder resultBuilder = new StringBuilder();

        Node topNode = node;

        
        double[] time = new double[2];
        
        if (!node.isRoot()) {	        
	        while (node.getChildren().size()==1) {
	        	double diff = node.getParent().getHeight() - node.getHeight();
	        	time[(int) node.getMetaData("type")] += diff;
	            node = node.getChild(0);
	        }
	        
	    	double diff = node.getParent().getHeight() - node.getHeight();
	    	time[(int) node.getMetaData("type")] += diff;
	    	
	    	double sum = time[0]+time[1];
	    	time[0] /= sum;
	    	time[1] /= sum;
        }
        

        if (!node.isLeaf()) {

            resultBuilder.append("(");
            boolean isFirst = true;
            for (Node child : node.getChildren()) {
                if (isFirst)
                    isFirst = false;
                else
                    resultBuilder.append(",");

                resultBuilder.append(getStrippedNewick(child));
            }
            

            resultBuilder.append(")");
        }

        if (node.getID() != null)
            resultBuilder.append(node.getNr()+Tree.taxaTranslationOffset);

        resultBuilder.append("[&").append(node.metaDataString);
        
//        System.out.println(node.metaDataString);
        
        if (!node.isRoot()) {
        	double sum = flatTypedTree.getNodeTime(node,0) + flatTypedTree.getNodeTime(node,1);
			double r1 = flatTypedTree.getNodeTime(node,0)/sum;
			double r2 = flatTypedTree.getNodeTime(node,1)/sum;
			
			resultBuilder.append(",sampled0=" + String.format("%f", time[0]));
			resultBuilder.append(",sampled1=" + String.format("%f", time[1]));
			
			resultBuilder.append(",time0=" + String.format("%f", r1));
			resultBuilder.append(",time1=" + String.format("%f", r2));
        }
		resultBuilder.append("]");



        double edgeLength = 0.0;
        if (topNode.getParent() != null)
            edgeLength = topNode.getParent().getHeight()-node.getHeight();

        resultBuilder.append(":").append(edgeLength);

        return resultBuilder.toString();
    }
}